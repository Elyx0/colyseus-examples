<!DOCTYPE html>
<html>

<head>
    <meta name="viewport" content="width=device-width" />

    <style>
        body {
            font-family: Tahoma, Geneva, sans-serif;
        }
    </style>

    <!-- colyseus.js client -->
    <script type="text/javascript" src="https://raw.githack.com/colyseus/colyseus.js/dev/dist/colyseus.dev.js"></script>
    <script type="text/javascript" src="https://ecsy.io/build/ecsy.js"></script>
</head>

<body>
    <h1>
        <a href="https://github.com/colyseus/colyseus-examples"><img
                src="https://cdn.jsdelivr.net/gh/colyseus/colyseus@master/media/header.png" height="100"
                alt="colyseus" /></a>
    </h1>

    <p>This example shows how to use a custom Room with <code>@colyseus/ecs</code>:</p>
    <p>Open another window to see live updates to the radius after you joined the room</p>

    <p>Open Developer Tools for log messages.</p>

    <p><strong>Commands</strong></p>

    <button id="join" onclick="join()">join ecs-demo-room</button>
    <button id="leave" onclick="leave()">leave ecs-demo-room</button>

    <h2>Room:</h2>
    <canvas style='border:1px solid red'>
    </canvas>

    <script>
        // The same components than the backend + some frontent specific
        const {
            Component,
            Types,
            System,
            TagComponent,
            World
        } = ECSY;
        // Initialize canvas
        let canvas = {
            width: 800,
            height: 600
        };

        class Network extends Component {}
        Network.schema = {
            sessionId: {
                type: Types.String
            },
            networkId: {
                type: Types.Number
            }
        };

        // Initialize canvas
        let canvasSelector = document.querySelector("canvas");
        canvasSelector.width = canvas.width;
        canvasSelector.height = canvas.height;
        let canvasWidth = canvasSelector.width;
        let canvasHeight = canvasSelector.height;
        let ctx = canvasSelector.getContext("2d");

        //----------------------
        // Components
        //----------------------

        // Velocity component
        class Velocity extends Component {}

        Velocity.schema = {
            x: {
                type: Types.Number
            },
            y: {
                type: Types.Number
            }
        };

        // Position component
        class Position extends Component {}

        Position.schema = {
            x: {
                type: Types.Number
            },
            y: {
                type: Types.Number
            }
        };

        // Shape component
        class Shape extends Component {}

        Shape.schema = {
            primitive: {
                type: Types.String,
                default: 'box'
            },
            radius: {
                type: Types.Number,
                default: 20,
            },
            color: {
                type: Types.String,
                default: '#000000',
            }
        };

        // Shape component
        class Size extends Component {}

        // Renderable component
        class Renderable extends TagComponent {

        }

        //----------------------
        // Systems
        //----------------------

        // MovableSystem
        class MovableSystem extends System {
            // This method will get called on every frame by default
            execute(delta, time) {
                // Iterate through all the entities on the query
                this.queries.moving.results.forEach(entity => {
                    const velocity = entity.getComponent(Velocity);
                    const position = entity.getMutableComponent(Position);
                    const {
                        radius
                    } = entity.getComponent(Shape);
                    position.x += velocity.x * delta;
                    position.y += velocity.y * delta;

                    if (position.x > canvasWidth + radius) position.x = -radius;
                    if (position.x < -radius) position.x = canvasWidth + radius;
                    if (position.y > canvasHeight + radius) position.y = -radius;
                    if (position.y < -radius) position.y = canvasHeight + radius;
                });
            }
        }

        // Define a query of entities that have "Velocity" and "Position" components
        MovableSystem.queries = {
            moving: {
                components: [Shape, Velocity, Position]
            }
        }

        // RendererSystem
        class RendererSystem extends System {
            // This method will get called on every frame by default
            execute(delta, time) {

                ctx.fillStyle = "#d4d4d4";
                ctx.fillRect(0, 0, canvasWidth, canvasHeight);

                // Iterate through all the entities on the query
                this.queries.renderables.results.forEach(entity => {
                    const {
                        radius,
                        color
                    } = entity.getComponent(Shape);
                    const position = entity.getComponent(Position);
                    this.drawCircle(position, radius, color);
                });
            }

            drawCircle(position, radius, color) {
                ctx.beginPath();
                ctx.arc(position.x, position.y, radius / 2, 0, 2 * Math.PI, false);
                ctx.fillStyle = color;
                ctx.fill();
                ctx.lineWidth = 2;
                ctx.strokeStyle = "#0b845b";
                ctx.stroke();
            }

        }

        // Define a query of entities that have "Renderable" and "Shape" components
        RendererSystem.queries = {
            renderables: {
                components: [Renderable, Shape]
            }
        }
    </script>

    <script>
        const host = window.document.location.host.replace(/:.*/, '');
        const client = new Colyseus.Client(location.protocol.replace("http", "ws") + "//" + host + (location.port ?
            ':' +
            location.port : ''));
        let ecs_demo_room;

        let simulationInterval;
        let joined = false;

        function join() {
            // Logged into your app and Facebook.
            joined = true;
            document.getElementById('join').disabled = true;

            client.joinOrCreate("ecs_demo").then(room_instance => {
                ecs_demo_room = room_instance;
                console.log(ecs_demo_room.serializer);
                onjoin();
                console.log("Joined ecs-demo room!");

            }).catch(e => {
                console.error("Error", e);
            });
        }

        function onjoin() {

            const world = new World();
            this.world = world;
            world
                .registerComponent(Network)
                .registerComponent(Velocity)
                .registerComponent(Position)
                .registerComponent(Shape)
                .registerComponent(Renderable)
                .registerSystem(MovableSystem)
                .registerSystem(RendererSystem);

            ecs_demo_room.onStateChange((state) => {
                console.log("ECS room state:", state);
            });

            // {Network: ƒ, Velocity: ƒ, Position: ƒ, Shape: ƒ, Renderable: ƒ}
            const componentNameToComponentFunction = world.componentsManager.Components.reduce((y, x) => {
                y[x.name] = x;
                return y
            }, {});

            const state = ecs_demo_room.state;
            state.entities.onAdd = function (stateEntity) {
                console.log('Added Entity:', stateEntity);
                const entity = world.createEntity(stateEntity.id);
                // In this demo every entity is renderable, adding it.
                entity.addComponent(Renderable);

                // Components Add
                stateEntity.components.onAdd = function (component, key) {

                    console.log('Added Component:', component, 'on state entity:', stateEntity);
                    if (component.cName && component.cName in componentNameToComponentFunction) {
                        // If we found that component name in our list registered by the world,
                        // instantiate the entity with the fields of the component.

                        const componentToAdd = componentNameToComponentFunction[component.cName];

                        //  _.pick exactly the fields from the Component.schema
                        let initComponentFields = {};
                        for (const key in componentToAdd.schema) {
                            const valueInStateComponent = component[key];
                            if (valueInStateComponent === undefined) throw new Error(
                                `Expected ${key} on ${component.cName}`);
                            initComponentFields[key] = valueInStateComponent;
                        }
                        // Finally add it to the component
                        entity.addComponent(componentToAdd, initComponentFields);
                        console.log('Added Component:', component.cName, 'on local entity:', entity.id, 'with:',
                            initComponentFields);

                    }
                }

                stateEntity.components.onRemove = function (component, key) {
                    // Check that I have the entity locally,
                    // Remove the component.
                    const entity = world.entityManager.getEntityByName(String(entity.id));
                    if (entity) {
                        if (component.cName && component.cName in
                            componentNameToComponentFunction) { // Maybe a helper for this
                            entity.removeComponent(componentNameToComponentFunction[component.cName]);
                            console.log('Removed Component:', component.cName, 'on local entity:', entity.id);
                        }
                    }

                    console.log('Removed Component:', component, 'on state entity:', stateEntity);

                }
            }

            state.entities.onRemove = function (stateEntity, key) {
                const entity = world.entityManager.getEntityByName(String(entity.id));
                if (entity) {
                    if (component.cName && component.cName in
                        componentNameToComponentFunction) { // Maybe a helper for this
                        entity.removeAllComponents();
                        console.log('Removed All Components on local entity:', entity.id);
                    }
                }
                console.log('Removed Entity:', stateEntity);
            }

            ecs_demo_room.onMessage("*", (args) => {
                console.log("Got message", ...args);
            });

            ecs_demo_room.onLeave(() => {
                console.log("Bye, bye!");
            });

            simulationInterval = setInterval(update, 1000 / 60);
        }

        let lastTime = Date.now();

        function update() {
            // Compute delta and elapsed time
            const time = Date.now();
            const delta = time - lastTime;

            // Run all the systems
            world.execute(delta, time);
            lastTime = time;
        }


        function leave() {
            if (ecs_demo_room) {
                ecs_demo_room.leave();
                clearInterval(simulationInterval);
                joined = false;
                document.getElementById('join').disabled = false;
            } else {
                console.warn("Not connected.");
            }
        }
    </script>

</body>

</html>